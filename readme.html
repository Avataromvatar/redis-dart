<h1 id="redis-dart">redis-dart</h1>
<p><a href="http://redis.io/">Redis</a> protocol parser and client It is designed to be fast and simple to use.</p>
<h3 id="curretly-supported-features">Curretly supported features:</h3>
<ul class="incremental">
<li>raw commands - this enables sending any command as raw data</li>
<li>unicode - strings are UTF8 encoded swen sending and decoded when received</li>
<li><a href="http://redis.io/topics/transactions">transactions</a> for executing multiple commands in atomic way</li>
<li><a href="http://redis.io/topics/pubsub">pubsub</a> helper for dispatcing messgaes trough single connection</li>
<li>performance - this counts as feture too</li>
</ul>
<h2 id="simple">Simple</h2>
<p>Redis protocol is coposition of array, strings(and bulk) and integers. For example executing command <code>SET key value</code> is no more that serializing array of strings <code>[&quot;SET&quot;,&quot;key&quot;,&quot;value&quot;]</code>. Cammands can be executed by</p>
<pre><code>Future f = command.send_object([&quot;SET&quot;,&quot;key&quot;,&quot;value&quot;]);</code></pre>
<p>This enables sending any command.</p>
<h2 id="fast">Fast</h2>
<p>It can made 110K SET or GET operations per second - tested localy on my laptop with i5 proc and [debian]{https://www.debian.org/} OS, This is code that yields such result and can give you first impression</p>
<pre><code>const int N = 200000;
int start;
RedisConnection conn = new RedisConnection();
conn.connect(&#39;localhost&#39;,6379).then((Command command){
  print(&quot;test started, please wait ...&quot;);
  start =  new DateTime.now().millisecondsSinceEpoch;
  command.pipe_start();
  for(int i=1;i&lt;N;i++){ 
    command.set(&quot;test $i&quot;,&quot;$i&quot;)
    .then((v){
      assert(v==&quot;OK&quot;);
    });
  }
  //last command will be executed and then processed last
  command.set(&quot;test $N&quot;,&quot;$N&quot;).then((v){
    assert(v==&quot;OK&quot;); 
    double diff = (new DateTime.now().millisecondsSinceEpoch - start)/1000.0;
    double perf = N/diff;
    print(&quot;$N operations done in $diff s\nperformance $perf/s&quot;);
  });
  command.pipe_end();
 });</code></pre>
<h2 id="transactions">Transactions</h2>
<p>Transactions are started by command MULTI and then complited with command EXEC. <code>.multi()</code> and <code>.exec()</code> and <code>class Transaction</code> are implemeted as additional helpers for checking result of each command executed during transation.</p>
<pre><code>RedisConnection conn = new RedisConnection();
conn.connect(&#39;localhost&#39;,6379).then((Command command){    
  command.multi().then((Transaction trans){
      trans.send_object([&quot;SET&quot;,&quot;val&quot;,&quot;0&quot;]);
      for(int i=0;i&lt;200000;++i){
        trans.send_object([&quot;INCR&quot;,&quot;val&quot;]).then((v){
          assert(i==v);
        });
      }
      trans.send_object([&quot;GET&quot;,&quot;val&quot;]).then((v){
        print(&quot;number is now $v&quot;);
      });
      trans.exec();
  });
});</code></pre>
<p>Take note here, that Future returned by <code>trans.send_object()</code> is executed after <code>.exec()</code> so make sure you dont try to call <code>.exec()</code> inside of such Future, becuase command will never complete.</p>
<h2 id="unicode">Unicode</h2>
<p>By default UTF8 encoding/decoding for string is used. Each string is coverted in binary array using UTF8 encoding. This makes ascii string compatible in both direction.</p>
<h2 id="pubsub">PubSub</h2>
<p>There is little helper that enables dispatching recevied messages.</p>
<p>[PSUBSCRIBE]{http://redis.io/commands/PSUBSCRIBE} on messages <code>a*</code> and <code>b*</code> Subscription sub = command.psubscribe([&quot;a<em>&quot;,&quot;b</em>&quot;]);</p>
<p><code>Subscription</code> allows registering trough <code>.add(String pattern,Function callback)</code> Unlike redis rich pattern matching, this pattern allows only for optional <code>*</code> wildchar at the end of string.</p>
<pre><code>  sub.add(&quot;abra*&quot;,(String chan,String message){
     print(&quot;on channel: $chan message: $message&quot;);
  });
  </code></pre>
<p>Here is full example from test code.</p>
<pre><code>int N = 100000;
RedisConnection conn1 = new RedisConnection();
RedisConnection conn2 = new RedisConnection();
Command cmd1;
Command cmd2;
Subscription sub;
conn1.connect(&#39;localhost&#39;,6379)
.then((Command cmd){
  cmd1 = cmd;
  return conn2.connect(&#39;localhost&#39;,6379);
})
.then((Command cmd){ 
  cmd2=cmd;
  sub = cmd2.psubscribe([&quot;a*&quot;,&quot;b*&quot;]);
  sub.add(&quot;*&quot;,(k,v){
    print(&quot;$k $v&quot;);
   });
})
.then((_){ 
  cmd1.send_object([&quot;PUBLISH&quot;,&quot;aaa&quot;,&quot;aa&quot;]);
  cmd1.send_object([&quot;PUBLISH&quot;,&quot;bbb&quot;,&quot;bb&quot;]);
  cmd1.send_object([&quot;PUBLISH&quot;,&quot;ccc&quot;,&quot;cc&quot;]); //we are not subscibed on this
});</code></pre>
<p>## Todo In near future - Better documentaion - Implement all &quot;generic comands&quot; with named commands</p>
